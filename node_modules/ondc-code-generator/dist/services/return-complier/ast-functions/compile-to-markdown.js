import { AllIn, AnyIn, AreUnique, ArePresent, EqualTo, FollowRegex, GreaterThan, LessThan, NoneIn, } from "../tokens.js";
const uniaryMessages = {
    [AreUnique.LABEL ?? "are unique"]: (variable, forNot) => `all values of {{{${variable}}}} must${forNot ? " **not**" : ""} be unique`,
    [ArePresent.LABEL ?? "are present"]: (variable, forNot) => `{{{${variable}}}} must${forNot ? " **not**" : ""} be present in the payload`,
};
const binaryMessages = {
    [AllIn.LABEL ?? "all in"]: (lhs, rhs, forNot) => `every element of {{{${lhs}}}} must${forNot ? " **not**" : ""} be in {{{${rhs}}}}`,
    [AnyIn.LABEL ?? "any in"]: (lhs, rhs, forNot) => `at least one element of {{{${lhs}}}} must${forNot ? " **not**" : ""} be in {{{${rhs}}}}`,
    [FollowRegex.LABEL ?? "follow regex"]: (lhs, rhs, forNot) => `all elements of {{{${lhs}}}} must${forNot ? " **not**" : ""} follow every regex in {{{${rhs}}}}`,
    [NoneIn.LABEL ?? "none in"]: (lhs, rhs, forNot) => `no element of {{{${lhs}}}} must${forNot ? " **not**" : ""} be in {{{${rhs}}}}`,
    [EqualTo.LABEL ?? "equal to"]: (lhs, rhs, forNot) => `{{{${lhs}}}} must${forNot ? " **not**" : ""} be equal to {{{${rhs}}}}`,
    [GreaterThan.LABEL ?? "greater than"]: (lhs, rhs, forNot) => `{{{${lhs}}}} must${forNot ? " **not**" : ""} be greater than {{{${rhs}}}}`,
    [LessThan.LABEL ?? "less than"]: (lhs, rhs, forNot) => `{{{${lhs}}}} must${forNot ? " **not**" : ""} be less than {{{${rhs}}}}`,
};
export function CompileToMarkdown(ast, pointer, depth = 0, forNot) {
    const indent = "  ".repeat(depth); // 2 spaces per depth level
    // Helper function to indent multi-line strings
    function indentMultilineString(str, indentLevel) {
        const subIndent = "  ".repeat(indentLevel);
        return str
            .split("\n")
            .map((line) => subIndent + line)
            .join("\n");
    }
    if (ast.type === "returnStatement") {
        const returnStatement = ast;
        const generated = CompileToMarkdown(returnStatement.expression, `${pointer}`, depth, forNot);
        return `${generated}`;
    }
    if (ast.type === "binaryOperator") {
        const binary = ast;
        const subMdLhs = CompileToMarkdown(binary.lhs, getNextPointer(pointer, 1), depth + 1, forNot);
        const subMdRhs = CompileToMarkdown(binary.rhs, getNextPointer(pointer, 2), depth + 1, forNot);
        const indentedSubMdLhs = indentMultilineString(subMdLhs, 0); // LHS already indented
        const indentedSubMdRhs = indentMultilineString(subMdRhs, 0); // RHS already indented
        if (binary.operator === "&&") {
            return `${indent}- **condition ${pointer}**: all of the following sub conditions must${forNot ? "**not**" : ""} be met:\n\n${indentedSubMdLhs}\n${indentedSubMdRhs}`;
        }
        if (binary.operator === "||") {
            return `${indent}- **condition ${pointer}**: any one of the following sub conditions must${forNot ? "**not**" : ""} be met:\n\n${indentedSubMdLhs}\n${indentedSubMdRhs}`;
        }
    }
    if (ast.type === "notOperator") {
        const not = ast;
        return CompileToMarkdown(not.expression, pointer, depth, !forNot);
    }
    if (ast.type === "customUniaryFunction") {
        const customFunction = ast;
        const func = customFunction.customFunction;
        const messageFunction = uniaryMessages[func];
        const lhs = customFunction.expression;
        return `${indent}- **condition ${pointer}**: ${messageFunction(lhs.name, forNot)}`;
    }
    if (ast.type === "customBinaryFunction") {
        const customFunction = ast;
        const func = customFunction.customFunction;
        const messageFunction = binaryMessages[func];
        const lhs = customFunction.lhs;
        const rhs = customFunction.rhs;
        return `${indent}- **condition ${pointer}**: ${messageFunction(lhs.name, rhs.name, forNot)}`;
    }
    throw new Error("Invalid AST node:" + JSON.stringify(ast));
}
function getNextPointer(currentPointer, nextIndex) {
    return `${currentPointer}.${nextIndex}`;
}
